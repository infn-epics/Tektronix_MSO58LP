# channel_asyn.template
# ASYN-based template for Tektronix MSO58LP channel
# High-speed acquisition using asynPortDriver parameters
#
# Macros:
#   P       - PV prefix
#   PORT    - ASYN port name (from drvTekMSO58LPConfigure)
#   CHANNEL - Channel number (1-8)
#   NELM    - Max waveform elements
#   CHANAME - Channel name/label (optional, default CH$(CHANNEL))

# ============================================================
# Channel Enable/Disable
# ============================================================
record(bo, "$(P):CH$(CHANNEL):Enable")
{
    field(DESC, "Enable channel $(CHANNEL) acquisition")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_ENABLE_$(CHANNEL)")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(PINI, "YES")
    field(VAL,  "0")
}

record(bi, "$(P):CH$(CHANNEL):Enable_RBV")
{
    field(DESC, "Channel $(CHANNEL) enable readback")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_ENABLE_$(CHANNEL)")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Data Acquisition Window - Per-channel start/stop points
# ============================================================
record(longout, "$(P):CH$(CHANNEL):DataStart")
{
    field(DESC, "Acquisition window start point")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_DATA_START_$(CHANNEL)")
    field(VAL,  "1")
    field(PINI, "YES")
    field(DRVL, "1")
    field(DRVH, "$(NELM)")
    field(LOPR, "1")
    field(HOPR, "$(NELM)")
}

record(longin, "$(P):CH$(CHANNEL):DataStart_RBV")
{
    field(DESC, "Acquisition window start readback")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_DATA_START_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

record(longout, "$(P):CH$(CHANNEL):DataStop")
{
    field(DESC, "Acquisition window stop point")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_DATA_STOP_$(CHANNEL)")
    field(VAL,  "$(NELM)")
    field(PINI, "YES")
    field(DRVL, "1")
    field(DRVH, "$(NELM)")
    field(LOPR, "1")
    field(HOPR, "$(NELM)")
}

record(longin, "$(P):CH$(CHANNEL):DataStop_RBV")
{
    field(DESC, "Acquisition window stop readback")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_DATA_STOP_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

# Calculated window size (for display)
record(calc, "$(P):CH$(CHANNEL):WindowSize")
{
    field(DESC, "Acquisition window size")
    field(INPA, "$(P):CH$(CHANNEL):DataStop_RBV CP")
    field(INPB, "$(P):CH$(CHANNEL):DataStart_RBV CP")
    field(CALC, "A-B+1")
    field(EGU,  "pts")
}

# ============================================================
# Data Width (bytes per sample: 1 or 2)
# ============================================================
record(mbbo, "$(P):CH$(CHANNEL):DataWidth")
{
    field(DESC, "Bytes per sample (1 or 2)")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_DATA_WIDTH_$(CHANNEL)")
    field(ZRST, "1 byte (8-bit)")
    field(ZRVL, "1")
    field(ONST, "2 bytes (16-bit)")
    field(ONVL, "2")
    field(VAL,  "1")
    field(PINI, "YES")
}

record(mbbi, "$(P):CH$(CHANNEL):DataWidth_RBV")
{
    field(DESC, "Bytes per sample readback")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_DATA_WIDTH_$(CHANNEL)")
    field(ZRST, "1 byte (8-bit)")
    field(ZRVL, "1")
    field(ONST, "2 bytes (16-bit)")
    field(ONVL, "2")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Channel Label
# ============================================================
record(stringout, "$(P):CH$(CHANNEL):Label")
{
    field(DESC, "Channel $(CHANNEL) label")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_LABEL_$(CHANNEL)")
    field(VAL,  "$(CHANAME=CH$(CHANNEL))")
    field(PINI, "YES")
}

record(stringin, "$(P):CH$(CHANNEL):Label_RBV")
{
    field(DESC, "Channel $(CHANNEL) label readback")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),0)TEK_CH_LABEL_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Channel Configuration - X Axis
# ============================================================
record(ai, "$(P):CH$(CHANNEL):Xinc")
{
    field(DESC, "X increment (time per sample)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_XINC_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "12")
    field(EGU,  "s")
}

record(stringin, "$(P):CH$(CHANNEL):Xunit")
{
    field(DESC, "X axis units")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),0)TEK_CH_XUNIT_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Channel Configuration - Y Axis
# ============================================================
record(ai, "$(P):CH$(CHANNEL):Ymult")
{
    field(DESC, "Y multiplier (scale factor)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_YMULT_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "9")
}

record(ai, "$(P):CH$(CHANNEL):Yoff")
{
    field(DESC, "Y offset (digitizer levels)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_YOFF_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "9")
}

record(ai, "$(P):CH$(CHANNEL):Yzero")
{
    field(DESC, "Y zero (voltage reference)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_YZERO_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "9")
    field(EGU,  "V")
}

record(stringin, "$(P):CH$(CHANNEL):Yunit")
{
    field(DESC, "Y axis units")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),0)TEK_CH_YUNIT_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Number of Points
# ============================================================
record(longin, "$(P):CH$(CHANNEL):NrPt")
{
    field(DESC, "Number of waveform points")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_NR_PT_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(EGU,  "pts")
}

# ============================================================
# Data Ready - Triggers waveform reads via I/O Intr
# ============================================================
record(longin, "$(P):CH$(CHANNEL):DataReady")
{
    field(DESC, "Data ready counter (triggers wfm read)")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_DATA_READY_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P):CH$(CHANNEL):RawWaveform")
}

# ============================================================
# Waveform Data - Raw (integer ADC counts)
# ============================================================
record(waveform, "$(P):CH$(CHANNEL):RawWaveform")
{
    field(DESC, "Raw waveform data (ADC counts)")
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn($(PORT),0)TEK_CH_WAVEFORM_$(CHANNEL)")
    field(SCAN, "Passive")
    field(FTVL, "LONG")
    field(NELM, "$(NELM)")
    field(FLNK, "$(P):CH$(CHANNEL):Waveform")
}

# ============================================================
# Waveform Data - Scaled (physical units)
# ============================================================
record(waveform, "$(P):CH$(CHANNEL):Waveform")
{
    field(DESC, "Scaled waveform data")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),0)TEK_CH_WAVEFORM_SCALED_$(CHANNEL)")
    field(SCAN, "Passive")
    field(FTVL, "DOUBLE")
    field(NELM, "$(NELM)")
    field(EGU,  "V")
    field(FLNK, "$(P):CH$(CHANNEL):TimeArray")
}

# ============================================================
# Time Array
# ============================================================
record(waveform, "$(P):CH$(CHANNEL):TimeArray")
{
    field(DESC, "Time array for waveform")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),0)TEK_CH_WAVEFORM_TIME_$(CHANNEL)")
    field(SCAN, "Passive")
    field(FTVL, "DOUBLE")
    field(NELM, "$(NELM)")
    field(EGU,  "s")
}

# ============================================================
# Channel Scale/Offset Control
# ============================================================
record(ao, "$(P):CH$(CHANNEL):Scale")
{
    field(DESC, "Vertical scale (V/div)")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_SCALE_$(CHANNEL)")
    field(PREC, "3")
    field(EGU,  "V/div")
}

record(ai, "$(P):CH$(CHANNEL):Scale_RBV")
{
    field(DESC, "Vertical scale readback")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_SCALE_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "3")
    field(EGU,  "V/div")
}

record(ao, "$(P):CH$(CHANNEL):Offset")
{
    field(DESC, "Vertical offset")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_OFFSET_$(CHANNEL)")
    field(PREC, "6")
    field(EGU,  "V")
}

record(ai, "$(P):CH$(CHANNEL):Offset_RBV")
{
    field(DESC, "Vertical offset readback")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_OFFSET_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "6")
    field(EGU,  "V")
}

# ============================================================
# Marker Positions (time-based, in seconds, for XYPlot markers)
# Interactive markers on the waveform plot define the stats window.
# Writing a new value recalculates statistics immediately in the driver.
# ============================================================
record(ao, "$(P):CH$(CHANNEL):MarkerStart")
{
    field(DESC, "Stats window start (time)")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_MARKER_START_$(CHANNEL)")
    field(PREC, "9")
    field(EGU,  "s")
    field(VAL,  "0")
    field(PINI, "YES")
}

record(ai, "$(P):CH$(CHANNEL):MarkerStart_RBV")
{
    field(DESC, "Stats window start readback")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_MARKER_START_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "9")
    field(EGU,  "s")
}

record(ao, "$(P):CH$(CHANNEL):MarkerEnd")
{
    field(DESC, "Stats window end (time)")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_MARKER_END_$(CHANNEL)")
    field(PREC, "9")
    field(EGU,  "s")
    field(VAL,  "0")
    field(PINI, "YES")
}

record(ai, "$(P):CH$(CHANNEL):MarkerEnd_RBV")
{
    field(DESC, "Stats window end readback")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_MARKER_END_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "9")
    field(EGU,  "s")
}

# Marker sample indices (computed by driver, read-only)
record(longin, "$(P):CH$(CHANNEL):MarkerStartSample")
{
    field(DESC, "Start marker in samples")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_MARKER_START_SAMPLE_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

record(longin, "$(P):CH$(CHANNEL):MarkerEndSample")
{
    field(DESC, "End marker in samples")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_MARKER_END_SAMPLE_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Waveform Statistics (computed by driver in readWaveformBinary)
# All stats are pushed via I/O Intr when a new waveform is acquired
# or when marker positions change.
# ============================================================
record(ai, "$(P):CH$(CHANNEL):Mean")
{
    field(DESC, "Waveform mean")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_STATS_MEAN_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "6")
    field(EGU,  "V")
}

record(ai, "$(P):CH$(CHANNEL):Min")
{
    field(DESC, "Waveform minimum")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_STATS_MIN_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "6")
    field(EGU,  "V")
}

record(ai, "$(P):CH$(CHANNEL):Max")
{
    field(DESC, "Waveform maximum")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_STATS_MAX_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "6")
    field(EGU,  "V")
}

record(ai, "$(P):CH$(CHANNEL):RMS")
{
    field(DESC, "Waveform RMS")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_STATS_RMS_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "6")
    field(EGU,  "V")
}

record(ai, "$(P):CH$(CHANNEL):Integral")
{
    field(DESC, "Waveform integral")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_STATS_INTEGRAL_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "9")
    field(EGU,  "V*s")
}

record(ai, "$(P):CH$(CHANNEL):PeakToPeak")
{
    field(DESC, "Waveform peak-to-peak")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_STATS_PP_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "6")
    field(EGU,  "V")
}

record(ai, "$(P):CH$(CHANNEL):StdDev")
{
    field(DESC, "Waveform standard deviation")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_STATS_STDDEV_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "6")
    field(EGU,  "V")
}

# ============================================================
# Per-Channel Refresh Rate (calculated by driver)
# ============================================================
record(ai, "$(P):CH$(CHANNEL):RefreshRate")
{
    field(DESC, "Actual refresh rate")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_REFRESH_RATE_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "2")
    field(EGU,  "Hz")
}

# ============================================================
# Reset Statistics
# ============================================================
record(bo, "$(P):CH$(CHANNEL):ResetStats")
{
    field(DESC, "Reset channel statistics")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_RESET_STATS_$(CHANNEL)")
    field(ZNAM, "Idle")
    field(ONAM, "Reset")
    field(HIGH, "0.1")
}

# ============================================================
# Charge Calculation (for BCM applications)
# ============================================================
record(ao, "$(P):CH$(CHANNEL):ChargeCoeff")
{
    field(DESC, "Charge coefficient")
    field(PREC, "12")
    field(VAL,  "$(COEFF=1.0)")
    field(PINI, "YES")
}

record(calc, "$(P):CH$(CHANNEL):Charge")
{
    field(DESC, "Calculated charge")
    field(INPA, "$(P):CH$(CHANNEL):Integral CP")
    field(INPB, "$(P):CH$(CHANNEL):ChargeCoeff CP")
    field(CALC, "A*B")
    field(PREC, "12")
    field(EGU,  "$(CHARGE_EGU=pC)")
}

# ============================================================
# Copy Markers to Data Window
# Quick-action records: write 1 to trigger records to copy
# current marker sample positions into DataStart/DataStop.
# ============================================================

# Copy MarkerStartSample -> DataStart
record(bo, "$(P):CH$(CHANNEL):CopyMarkerStart")
{
    field(DESC, "Copy marker start to DataStart")
    field(ZNAM, "Idle")
    field(ONAM, "Copy")
    field(HIGH, "0.1")
    field(FLNK, "$(P):CH$(CHANNEL):copyMkrStart_")
}

record(calcout, "$(P):CH$(CHANNEL):copyMkrStart_")
{
    field(DESC, "Copy start sample to DataStart")
    field(INPA, "$(P):CH$(CHANNEL):MarkerStartSample NPP NMS")
    field(CALC, "A>0?A:1")
    field(DOPT, "Use CALC")
    field(OUT,  "$(P):CH$(CHANNEL):DataStart PP")
}

# Copy MarkerEndSample -> DataStop
record(bo, "$(P):CH$(CHANNEL):CopyMarkerEnd")
{
    field(DESC, "Copy marker end to DataStop")
    field(ZNAM, "Idle")
    field(ONAM, "Copy")
    field(HIGH, "0.1")
    field(FLNK, "$(P):CH$(CHANNEL):copyMkrEnd_")
}

record(calcout, "$(P):CH$(CHANNEL):copyMkrEnd_")
{
    field(DESC, "Copy end sample to DataStop")
    field(INPA, "$(P):CH$(CHANNEL):MarkerEndSample NPP NMS")
    field(CALC, "A>0?A:1")
    field(DOPT, "Use CALC")
    field(OUT,  "$(P):CH$(CHANNEL):DataStop PP")
}

# Copy both markers to Data Window at once
record(bo, "$(P):CH$(CHANNEL):CopyMarkersToWindow")
{
    field(DESC, "Copy both markers to data window")
    field(ZNAM, "Idle")
    field(ONAM, "Copy")
    field(HIGH, "0.1")
    field(FLNK, "$(P):CH$(CHANNEL):copyMkrBothStart_")
}

record(calcout, "$(P):CH$(CHANNEL):copyMkrBothStart_")
{
    field(DESC, "Copy start sample to DataStart")
    field(INPA, "$(P):CH$(CHANNEL):MarkerStartSample NPP NMS")
    field(CALC, "A>0?A:1")
    field(DOPT, "Use CALC")
    field(OUT,  "$(P):CH$(CHANNEL):DataStart PP")
    field(FLNK, "$(P):CH$(CHANNEL):copyMkrBothEnd_")
}

record(calcout, "$(P):CH$(CHANNEL):copyMkrBothEnd_")
{
    field(DESC, "Copy end sample to DataStop")
    field(INPA, "$(P):CH$(CHANNEL):MarkerEndSample NPP NMS")
    field(CALC, "A>0?A:1")
    field(DOPT, "Use CALC")
    field(OUT,  "$(P):CH$(CHANNEL):DataStop PP")
}
