# channel_asyn.template
# ASYN-based template for Tektronix MSO58LP channel
# High-speed acquisition using asynPortDriver parameters
#
# Macros:
#   P       - PV prefix
#   PORT    - ASYN port name (from drvTekMSO58LPConfigure)
#   CHANNEL - Channel number (1-8)
#   NELM    - Max waveform elements
#   CHANAME - Channel name/label (optional, default CH$(CHANNEL))

# ============================================================
# Channel Enable/Disable
# ============================================================
record(bo, "$(P):CH$(CHANNEL):Enable")
{
    field(DESC, "Enable channel $(CHANNEL) acquisition")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_ENABLE_$(CHANNEL)")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(PINI, "YES")
    field(VAL,  "0")
}

record(bi, "$(P):CH$(CHANNEL):Enable_RBV")
{
    field(DESC, "Channel $(CHANNEL) enable readback")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_ENABLE_$(CHANNEL)")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Data Acquisition Window - Per-channel start/stop points
# ============================================================
record(longout, "$(P):CH$(CHANNEL):DataStart")
{
    field(DESC, "Acquisition window start point")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_DATA_START_$(CHANNEL)")
    field(VAL,  "1")
    field(PINI, "YES")
    field(DRVL, "1")
    field(DRVH, "$(NELM)")
    field(LOPR, "1")
    field(HOPR, "$(NELM)")
}

record(longin, "$(P):CH$(CHANNEL):DataStart_RBV")
{
    field(DESC, "Acquisition window start readback")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_DATA_START_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

record(longout, "$(P):CH$(CHANNEL):DataStop")
{
    field(DESC, "Acquisition window stop point")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_DATA_STOP_$(CHANNEL)")
    field(VAL,  "$(NELM)")
    field(PINI, "YES")
    field(DRVL, "1")
    field(DRVH, "$(NELM)")
    field(LOPR, "1")
    field(HOPR, "$(NELM)")
}

record(longin, "$(P):CH$(CHANNEL):DataStop_RBV")
{
    field(DESC, "Acquisition window stop readback")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_DATA_STOP_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

# Calculated window size (for display)
record(calc, "$(P):CH$(CHANNEL):WindowSize")
{
    field(DESC, "Acquisition window size")
    field(INPA, "$(P):CH$(CHANNEL):DataStop_RBV CP")
    field(INPB, "$(P):CH$(CHANNEL):DataStart_RBV CP")
    field(CALC, "A-B+1")
    field(EGU,  "pts")
}

# ============================================================
# Data Width (bytes per sample: 1 or 2)
# ============================================================
record(mbbo, "$(P):CH$(CHANNEL):DataWidth")
{
    field(DESC, "Bytes per sample (1 or 2)")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_DATA_WIDTH_$(CHANNEL)")
    field(ZRST, "1 byte (8-bit)")
    field(ZRVL, "1")
    field(ONST, "2 bytes (16-bit)")
    field(ONVL, "2")
    field(VAL,  "1")
    field(PINI, "YES")
}

record(mbbi, "$(P):CH$(CHANNEL):DataWidth_RBV")
{
    field(DESC, "Bytes per sample readback")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_DATA_WIDTH_$(CHANNEL)")
    field(ZRST, "1 byte (8-bit)")
    field(ZRVL, "1")
    field(ONST, "2 bytes (16-bit)")
    field(ONVL, "2")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Channel Label
# ============================================================
record(stringout, "$(P):CH$(CHANNEL):Label")
{
    field(DESC, "Channel $(CHANNEL) label")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_LABEL_$(CHANNEL)")
    field(VAL,  "$(CHANAME=CH$(CHANNEL))")
    field(PINI, "YES")
}

record(stringin, "$(P):CH$(CHANNEL):Label_RBV")
{
    field(DESC, "Channel $(CHANNEL) label readback")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),0)TEK_CH_LABEL_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Channel Configuration - X Axis
# ============================================================
record(ai, "$(P):CH$(CHANNEL):Xinc")
{
    field(DESC, "X increment (time per sample)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_XINC_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "12")
    field(EGU,  "s")
}

record(stringin, "$(P):CH$(CHANNEL):Xunit")
{
    field(DESC, "X axis units")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),0)TEK_CH_XUNIT_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Channel Configuration - Y Axis
# ============================================================
record(ai, "$(P):CH$(CHANNEL):Ymult")
{
    field(DESC, "Y multiplier (scale factor)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_YMULT_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "9")
}

record(ai, "$(P):CH$(CHANNEL):Yoff")
{
    field(DESC, "Y offset (digitizer levels)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_YOFF_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "9")
}

record(ai, "$(P):CH$(CHANNEL):Yzero")
{
    field(DESC, "Y zero (voltage reference)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_YZERO_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "9")
    field(EGU,  "V")
}

record(stringin, "$(P):CH$(CHANNEL):Yunit")
{
    field(DESC, "Y axis units")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),0)TEK_CH_YUNIT_$(CHANNEL)")
    field(SCAN, "I/O Intr")
}

# ============================================================
# Number of Points
# ============================================================
record(longin, "$(P):CH$(CHANNEL):NrPt")
{
    field(DESC, "Number of waveform points")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_NR_PT_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(EGU,  "pts")
}

# ============================================================
# Data Ready - Triggers waveform reads via I/O Intr
# ============================================================
record(longin, "$(P):CH$(CHANNEL):DataReady")
{
    field(DESC, "Data ready counter (triggers wfm read)")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),0)TEK_CH_DATA_READY_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P):CH$(CHANNEL):RawWaveform")
}

# ============================================================
# Waveform Data - Raw (integer ADC counts)
# ============================================================
record(waveform, "$(P):CH$(CHANNEL):RawWaveform")
{
    field(DESC, "Raw waveform data (ADC counts)")
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn($(PORT),0)TEK_CH_WAVEFORM_$(CHANNEL)")
    field(SCAN, "Passive")
    field(FTVL, "LONG")
    field(NELM, "$(NELM)")
    field(FLNK, "$(P):CH$(CHANNEL):Waveform")
}

# ============================================================
# Waveform Data - Scaled (physical units)
# ============================================================
record(waveform, "$(P):CH$(CHANNEL):Waveform")
{
    field(DESC, "Scaled waveform data")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),0)TEK_CH_WAVEFORM_SCALED_$(CHANNEL)")
    field(SCAN, "Passive")
    field(FTVL, "DOUBLE")
    field(NELM, "$(NELM)")
    field(EGU,  "V")
    field(FLNK, "$(P):CH$(CHANNEL):TimeArray")
}

# ============================================================
# Time Array
# ============================================================
record(waveform, "$(P):CH$(CHANNEL):TimeArray")
{
    field(DESC, "Time array for waveform")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),0)TEK_CH_WAVEFORM_TIME_$(CHANNEL)")
    field(SCAN, "Passive")
    field(FTVL, "DOUBLE")
    field(NELM, "$(NELM)")
    field(EGU,  "s")
    field(FLNK, "$(P):CH$(CHANNEL):CalcStats_")
}

# ============================================================
# Channel Scale/Offset Control
# ============================================================
record(ao, "$(P):CH$(CHANNEL):Scale")
{
    field(DESC, "Vertical scale (V/div)")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_SCALE_$(CHANNEL)")
    field(PREC, "3")
    field(EGU,  "V/div")
}

record(ai, "$(P):CH$(CHANNEL):Scale_RBV")
{
    field(DESC, "Vertical scale readback")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_SCALE_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "3")
    field(EGU,  "V/div")
}

record(ao, "$(P):CH$(CHANNEL):Offset")
{
    field(DESC, "Vertical offset")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_OFFSET_$(CHANNEL)")
    field(PREC, "6")
    field(EGU,  "V")
}

record(ai, "$(P):CH$(CHANNEL):Offset_RBV")
{
    field(DESC, "Vertical offset readback")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_OFFSET_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "6")
    field(EGU,  "V")
}

# ============================================================
# Marker Positions (time-based, in seconds, for XYPlot markers)
# Interactive markers on the waveform plot define the stats window
# ============================================================
record(ao, "$(P):CH$(CHANNEL):MarkerStart")
{
    field(DESC, "Stats window start (time)")
    field(PREC, "9")
    field(EGU,  "s")
    field(VAL,  "0")
    field(PINI, "YES")
}

record(ao, "$(P):CH$(CHANNEL):MarkerEnd")
{
    field(DESC, "Stats window end (time)")
    field(PREC, "9")
    field(EGU,  "s")
    field(VAL,  "0")
    field(PINI, "YES")
}

# Convert marker time positions to sample indices for wavestats
# sample = time / xinc  (clamped to 0..NrPt)
record(calc, "$(P):CH$(CHANNEL):MarkerStartSample")
{
    field(DESC, "Start marker in samples")
    field(INPA, "$(P):CH$(CHANNEL):MarkerStart CP")
    field(INPB, "$(P):CH$(CHANNEL):Xinc CP")
    field(INPC, "$(P):CH$(CHANNEL):NrPt CP")
    field(CALC, "B>0?MAX(0,MIN(NINT(A/B),C)):0")
}

record(calc, "$(P):CH$(CHANNEL):MarkerEndSample")
{
    field(DESC, "End marker in samples")
    field(INPA, "$(P):CH$(CHANNEL):MarkerEnd CP")
    field(INPB, "$(P):CH$(CHANNEL):Xinc CP")
    field(INPC, "$(P):CH$(CHANNEL):NrPt CP")
    field(CALC, "A<=0&&B>0?C:B>0?MAX(0,MIN(NINT(A/B),C)):0")
}

# ============================================================
# Waveform Statistics (using aSub for efficiency)
# ============================================================
record(aSub, "$(P):CH$(CHANNEL):CalcStats_")
{
    field(DESC, "Calculate waveform statistics")
    field(SNAM, "wavestats")
    field(FTA,  "DOUBLE")
    field(INPA, "$(P):CH$(CHANNEL):Xinc NPP")
    field(FTB,  "DOUBLE")
    field(INPB, "$(COEFF=1.0)")
    field(FTC,  "DOUBLE")
    field(INPC, "$(P):CH$(CHANNEL):Waveform CA NMS")
    field(NEC,  "$(NELM)")
    field(FTD,  "LONG")
    field(INPD, "$(P):CH$(CHANNEL):NrPt NPP")
    field(FTE,  "LONG")
    field(INPE, "$(P):CH$(CHANNEL):MarkerStartSample NPP")
    field(FTF,  "LONG")
    field(INPF, "$(P):CH$(CHANNEL):MarkerEndSample NPP")
    field(FTVA, "DOUBLE")
    field(OUTA, "$(P):CH$(CHANNEL):Integral PP")
    field(FTVB, "DOUBLE")
    field(OUTB, "$(P):CH$(CHANNEL):Mean PP")
    field(FTVC, "DOUBLE")
    field(OUTC, "$(P):CH$(CHANNEL):Min PP")
    field(FTVD, "DOUBLE")
    field(OUTD, "$(P):CH$(CHANNEL):Max PP")
    field(FTVE, "DOUBLE")
    field(OUTE, "$(P):CH$(CHANNEL):RMS PP")
    field(FLNK, "$(P):CH$(CHANNEL):PeakToPeak")
}

record(ai, "$(P):CH$(CHANNEL):Integral")
{
    field(DESC, "Waveform integral")
    field(PREC, "9")
    field(EGU,  "V*s")
}

record(ai, "$(P):CH$(CHANNEL):Mean")
{
    field(DESC, "Waveform mean")
    field(PREC, "6")
    field(EGU,  "V")
}

record(ai, "$(P):CH$(CHANNEL):Min")
{
    field(DESC, "Waveform minimum")
    field(PREC, "6")
    field(EGU,  "V")
}

record(ai, "$(P):CH$(CHANNEL):Max")
{
    field(DESC, "Waveform maximum")
    field(PREC, "6")
    field(EGU,  "V")
}

record(ai, "$(P):CH$(CHANNEL):RMS")
{
    field(DESC, "Waveform RMS")
    field(PREC, "6")
    field(EGU,  "V")
}

# ============================================================
# Per-Channel Refresh Rate (calculated by driver)
# ============================================================
record(ai, "$(P):CH$(CHANNEL):RefreshRate")
{
    field(DESC, "Actual refresh rate")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),0)TEK_CH_REFRESH_RATE_$(CHANNEL)")
    field(SCAN, "I/O Intr")
    field(PREC, "2")
    field(EGU,  "Hz")
}

# ============================================================
# Reset Statistics
# ============================================================
record(bo, "$(P):CH$(CHANNEL):ResetStats")
{
    field(DESC, "Reset channel statistics")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TEK_CH_RESET_STATS_$(CHANNEL)")
    field(ZNAM, "Idle")
    field(ONAM, "Reset")
    field(HIGH, "0.1")
}

# Derived statistics
record(calc, "$(P):CH$(CHANNEL):PeakToPeak")
{
    field(DESC, "Waveform peak-to-peak")
    field(INPA, "$(P):CH$(CHANNEL):Max CP")
    field(INPB, "$(P):CH$(CHANNEL):Min CP")
    field(CALC, "A-B")
    field(PREC, "6")
    field(EGU,  "V")
}

record(calc, "$(P):CH$(CHANNEL):StdDev")
{
    field(DESC, "Waveform standard deviation")
    field(INPA, "$(P):CH$(CHANNEL):RMS CP")
    field(INPB, "$(P):CH$(CHANNEL):Mean CP")
    field(CALC, "SQR(A*A-B*B)")
    field(PREC, "6")
    field(EGU,  "V")
}

# ============================================================
# Charge Calculation (for BCM applications)
# ============================================================
record(ao, "$(P):CH$(CHANNEL):ChargeCoeff")
{
    field(DESC, "Charge coefficient")
    field(PREC, "12")
    field(VAL,  "$(COEFF=1.0)")
    field(PINI, "YES")
}

record(calc, "$(P):CH$(CHANNEL):Charge")
{
    field(DESC, "Calculated charge")
    field(INPA, "$(P):CH$(CHANNEL):Integral CP")
    field(INPB, "$(P):CH$(CHANNEL):ChargeCoeff CP")
    field(CALC, "A*B")
    field(PREC, "12")
    field(EGU,  "$(CHARGE_EGU=pC)")
}
