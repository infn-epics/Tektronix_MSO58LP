OutTerminator = '\n';
ReplyTimeout = 500;

getIDN {
    out "*IDN?";
    #Read no more that 39 chars (EPICS limit)
    in "%/(.{0,39})/";
    ExtraInput = Ignore;
}

readIDNParts {
    out "*IDN?";
    in "%(\$1)[_a-zA-Z0-9],%(\$2)[_a-zA-Z0-9],%(\$3)[_a-zA-Z0-9],CF:%(\$4)[a-zA-Z0-9\.] FV:%(\$5)[_a-zA-Z0-9\.]";
	ExtraInput = Ignore;

}


getXINC {
	#get x increment for plot
	out ":DATa:SOUrce CH\$1";
	wait 10;
	out "WFMOutpre:XINcr?";
	in "%f";
	ExtraInput = Ignore;
}

getYMULT {
	#get y multiplier for plot
	out ":DATa:SOUrce CH\$1";
	wait 10;
	out "WFMOutpre:YMUlt?";
	in "%f";
	ExtraInput = Ignore;
}

getYOff {
	#get y multiplier for plot
	out ":DATa:SOUrce CH\$1";
	wait 10;
	out "WFMOutpre:YZEro?";
	in "%f";
	ExtraInput = Ignore;
}

getXUNIT {
	#get x unit for plot
	out ":DATa:SOUrce CH\$1";
	wait 10;
	out "WFMOutpre:XUNit?";
	in '%/([a-zA-Z]+)/';
	ExtraInput = Ignore;
}

getYUNIT {
	#get y unit for plot
	out ":DATa:SOUrce CH\$1";
	wait 10;
	out "WFMOutpre:YUNit?";
	in '%/([a-zA-Z]+)/';
	ExtraInput = Ignore;
}

getWFID {
	#get waveform ID string with channel information
	#Returns: "Ch1, DC coupling, 100.0mV/div, 4.000us/div, 10000 points, Sample mode"
	out ":DATa:SOUrce CH\$1";
	wait 10;
	out "WFMOutpre:WFId?";
	in '"%[^\"]"';
	ExtraInput = Ignore;
}

getNR_PT {
	#get number of points in waveform
	#Returns: 10000 (integer indicating number of data points)
	out ":DATa:SOUrce CH\$1";
	wait 10;
	out "WFMOutpre:NR_Pt?";
	in "%d";
	ExtraInput = Ignore;
}

setNR_PT {
	#set horizontal record length (number of points)
	#Sets the number of data points in the waveform record
	#Valid values: 500, 1000, 2500, 5000, 10000, 25000, 50000, 100000, 250000, etc.
	out "HORizontal:RECOrdlength %d";
	wait 100;
	ExtraInput = Ignore;
}

setTransfer {
#	out ":VERBOSE 0";
#	wait 1;
#	out "HEADER 0";
#	wait 1;
	out ":DATa:SOUrce CH\$1";
	wait 1;
	out ":DATa:STARt %(\$2)d";
	wait 1;
	out ":DATa:STOP %(\$3)d";
	wait 1;
	out ":DATa:ENCdg ASCIi";
	wait 1;
	out ":DATa:WIDth 2";
	wait 1;
	ExtraInput = Ignore;
}
getYDATA {
	#ask scope for y data points
	# out ":VERBOSE 0";
	# wait 1;
	# out "HEADER 0";
	# wait 1;
	out ":DATa:SOUrce CH\$1";
	wait 10;
	out ":DATa:STARt %(\$2)d";
	wait 10;
	out ":DATa:STOP %(\$3)d";
	wait 10;
	out ":DATa:ENCdg ASCIi";
	#out "DATa:ENCdg RIBinary";        # Signed binary encoding

	wait 10;
	out ":DATa:WIDth 2";
	wait 10;
	out ":CURVe?";
	separator=",";
	in "%d";
	#in  "%#02r";                        # Read binary block as 16-bit words
	ExtraInput = Ignore;
}
getYDATAs {
	out ":VERBOSE 0";
	wait 1;
	out "HEADER 0";
	wait 1;
	out ":DATa:SOUrce CH\$1";
	wait 1;
	out ":DATa:ENCdg ASCIi";
	wait 1;

	out ":CURVe?";
	separator=",";
	in "%d";
	ExtraInput = Ignore;
}
setLabel{
	out "CH\$1:LABEL:NAME \"%s\"";
	ExtraInput = Ignore;

}

# ===== Measurement Commands =====

setMeasSource {
	# Set measurement source channel
	# Usage: setMeasSource(MEAS_NUM)
	# Input: Channel number (1-8)
	out "MEASUrement:MEAS\$1:SOUrce CH%d";
	wait 10;
	ExtraInput = Ignore;
}

setMeasType {
	# Set measurement type
	# Usage: setMeasType(MEAS_NUM)
	# Input: Measurement type string (e.g., AMPLITUDE, FREQUENCY, PERIOD, MEAN, RMS, etc.)
	# Valid types: AMPLITUDE, AREA, BURST, CARea, CMEan, CRMs, DELAY, FALL, FREQUENCY,
	#              HIGH, LOW, MAXIMUM, MEAN, MINIMUM, NOVERSHOOT, NWIDTH, PDUTY, PEAK2PEAK,
	#              PERIOD, PHASE, POVERSHOOT, PWIDTH, RISE, RMS, SIGMA1, SIGMA2, SIGMA3
	out "MEASUrement:MEAS\$1:TYPe %s";
	wait 10;
	ExtraInput = Ignore;
}

setMeasState {
	# Enable or disable measurement
	# Usage: setMeasState(MEAS_NUM)
	# Input: 0=OFF, 1=ON
	out "MEASUrement:MEAS\$1:STATE %{OFF|ON}";
	wait 10;
	ExtraInput = Ignore;
}

getMeasValue {
	# Get current measurement value
	# Usage: getMeasValue(MEAS_NUM)
	# Returns: Measurement value as float
	out "MEASUrement:MEAS\$1:RESUlts:CURRentacq:MEAN?";
	in "%f";
	ExtraInput = Ignore;
}

getMeasMean {
	# Get measurement mean (all acquisitions)
	# Usage: getMeasMean(MEAS_NUM)
	# Returns: Mean value as float
	out "MEASUrement:MEAS\$1:RESUlts:ALLAcqs:MEAN?";
	in "%f";
	ExtraInput = Ignore;
}

getMeasMin {
	# Get measurement minimum (all acquisitions)
	# Usage: getMeasMin(MEAS_NUM)
	# Returns: Minimum value as float
	out "MEASUrement:MEAS\$1:RESUlts:ALLAcqs:MINimum?";
	in "%f";
	ExtraInput = Ignore;
}

getMeasMax {
	# Get measurement maximum (all acquisitions)
	# Usage: getMeasMax(MEAS_NUM)
	# Returns: Maximum value as float
	out "MEASUrement:MEAS\$1:RESUlts:ALLAcqs:MAXimum?";
	in "%f";
	ExtraInput = Ignore;
}

getMeasStddev {
	# Get measurement standard deviation (all acquisitions)
	# Usage: getMeasStddev(MEAS_NUM)
	# Returns: Standard deviation as float
	out "MEASUrement:MEAS\$1:RESUlts:ALLAcqs:STDDev?";
	in "%f";
	ExtraInput = Ignore;
}

getMeasState {
	# Get measurement state
	# Usage: getMeasState(MEAS_NUM)
	# Returns: ON or OFF
	out "MEASUrement:MEAS\$1:STATE?";
	in "%[^\r\n]";
	ExtraInput = Ignore;
}

getMeasUnits {
	# Get measurement units
	# Usage: getMeasUnits(MEAS_NUM)
	# Returns: Units string (V, s, Hz, etc.)
	out "MEASUrement:MEAS\$1:RESUlts:CURRentacq:UNIts?";
	in '"%[^\"]"';
	ExtraInput = Ignore;
}

resetMeasStats {
	# Reset measurement statistics
	# Usage: resetMeasStats(MEAS_NUM)
	out "MEASUrement:MEAS\$1:RESUlts:ALLAcqs:CLEar";
	wait 10;
	ExtraInput = Ignore;
}
